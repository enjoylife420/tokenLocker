{"version":3,"sources":["web3.js"],"names":["lockerAddress","swapTokenLockerFactory","airdropAddress","provider","serverApi","explorer","deposit","token","amount","date","account","a","unlockDate","Date","UTCTimestamp","Math","round","getTime","web3","Web3","contract","eth","Contract","lockerContractAbi","methods","feesInETH","call","feeInETH","address","BigInt","send","from","value","pow","toString","result","status","withdraw","id","approve","erc20Abi","utils","toBN","approveToken","deployedContract","allowance","getTokenBalance","getData","axios","get","response","lockerDataByWallet","data","checkWalletAddress","walletAddress","isAddress","getLastDeployedContract","lastDeployedAddress","deployContract","abi","createTokenLocker","sendTokenVesting","csvData","_users","_amounts","_lockHours","_sendAmount","decimals","map","each","push","period","length","slice","console","log","sendLockTokenMany","getClaimTokenList","factoryContract","getAllContracts","allContracts","multicall","Multicall","web3Instance","tryAggregate","contractCallContext","index","reference","contractAddress","calls","methodName","methodParameters","returnData","Object","entries","results","key","callsReturnContext","returnValues","hex","claimedAmount","lockTimestamp","lastUpdated","lockHours","name","symbol","claimToken","tokenDetail","currentTimestamp","floor","now","state","reason","passedHours","availableAmount","airdrop"],"mappings":"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","file":"static/js/3.f98868e3.chunk.js","sourcesContent":["import Web3 from \"web3\"\r\nimport {\r\n    Multicall\r\n  } from 'ethereum-multicall';\r\n\r\nimport lockerContractAbi from \"./locker_abi.json\"\r\nimport erc20Abi from \"./erc20_abi.json\"\r\nimport liquidityPoolAbi from \"./liquidityPool_abi.json\"\r\nimport axios from 'axios'\r\n\r\n// const lockerAddress = \"0x9D1018Cf42c12D78D073C38A79eCaB18A4FDc2A5\";\r\n// const lockerAddress = \"0x7E73A50B8F78F8Ad584d86Aab0ba966d1BE33bf1\";\r\n// const lockerAddress = \"0x54eFc25b4B3d0f08494B685F41ccd834bb95AA23\";\r\n// const lockerAddress = \"0xC25689105C2F54cd7916e5c8101cFEBA7a08093E\";\r\nexport const lockerAddress = \"0xe7B5c1aFffe4297adE4527C41CA9800C7905E7Eb\";\r\n// const swapTokenLockerFactory = '0x6a33a15d826e59792b60dec950e8af2fa7d58f9e';\r\nexport const swapTokenLockerFactory = '0x74818F8D9C0666ab332Af6B8DCBc448e1F10A133';\r\nexport const airdropAddress = \"0xa155DF21209A845dbf894070b51Cc44466F23d6e\";\r\n\r\n// const provider = \"https://api.avax.network/ext/bc/C/rpc\";\r\nconst provider = \"https://api.avax-test.network/ext/bc/C/rpc\";\r\n\r\nconst serverApi = 'https://hidden-scrubland-96810.herokuapp.com/api';\r\n\r\nexport const explorer = \"https://testnet.snowtrace.io\";\r\n\r\nexport const deposit = async (provider, token, amount, date, account) => {\r\n    let unlockDate = new Date(date);\r\n    let UTCTimestamp = Math.round(unlockDate.getTime() / 1000)\r\n    let web3 = new Web3(provider);\r\n    let contract = new web3.eth.Contract(lockerContractAbi, lockerAddress);\r\n    let feeInETH = await contract.methods.feesInETH().call();\r\n    let result = await contract.methods[\"lockTokens\"](token.address, account, BigInt(amount), UTCTimestamp).send({from: account, value: BigInt(feeInETH * Math.pow(10, 18)).toString()});\r\n    return result.status;\r\n}\r\n\r\nexport const withdraw = async (provider, id, account) => {\r\n    let web3 = new Web3(provider);\r\n    let contract = new web3.eth.Contract(lockerContractAbi, lockerAddress);\r\n    let result = await contract.methods[\"withdrawTokens\"](id).send({\r\n        from: account\r\n    });\r\n    return result.status;\r\n}\r\n\r\nexport const approve = async (provider, token, account) => {\r\n    let web3 = new Web3(provider);\r\n    let contract = new web3.eth.Contract(erc20Abi, token.address);\r\n    let result = await contract.methods[\"approve\"](lockerAddress, web3.utils.toBN(\"115792089237316195423570985008687907853269984665640564039457584007913129639935\")).send({from: account});\r\n    return result.status;\r\n}\r\n\r\nexport const approveToken = async (provider, token, account, deployedContract) => {\r\n    let web3 = new Web3(provider);\r\n    let contract = new web3.eth.Contract(erc20Abi, token);\r\n    let result = await contract.methods[\"approve\"](deployedContract, web3.utils.toBN(\"115792089237316195423570985008687907853269984665640564039457584007913129639935\")).send({from: account});\r\n    return result.status;\r\n}\r\n\r\nexport const allowance = async (token, account) => {\r\n    let web3 = new Web3(provider);\r\n    let contract = new web3.eth.Contract(erc20Abi, token.address);\r\n    let result = await contract.methods[\"allowance\"](account, lockerAddress).call();\r\n    return result;\r\n}\r\n\r\nexport const getTokenBalance = async (token, account) => {\r\n    let web3 = new Web3(provider);\r\n    let contract = new web3.eth.Contract(erc20Abi, token.address);\r\n    let result = await contract.methods[\"balanceOf\"](account).call();\r\n    return result;\r\n}\r\n\r\nexport const getRawData = async (account) => {\r\n    let web3 = new Web3(provider);\r\n    let contract = new web3.eth.Contract(lockerContractAbi, lockerAddress);\r\n    let depositIds = await contract.methods[\"getAllDepositIds\"]().call();\r\n    if (!depositIds.length) return []\r\n    const multicall = new Multicall({ web3Instance: web3, tryAggregate: true });\r\n    let contractCallContext = {\r\n        reference: \"lockedToken\",\r\n        contractAddress: lockerAddress,\r\n        abi: lockerContractAbi,\r\n        calls: depositIds.map(each => {\r\n            return { reference: 'lockedTokensCall', methodName: 'lockedToken', methodParameters: [each] }\r\n        })\r\n    }\r\n    let response = await multicall.call(contractCallContext);\r\n    const returnValues = [];\r\n    response.results.lockedToken.callsReturnContext.map(each => {\r\n        const returnValue = {\r\n            id: each.methodParameters[0],\r\n            token: each.returnValues[0],\r\n            owner: each.returnValues[1],\r\n            amount: BigInt(parseInt(each.returnValues[2].hex, 16)).toString(),\r\n            timestamp: parseInt(each.returnValues[3].hex, 16),\r\n            isWithdrawn: each.returnValues[4]\r\n        }\r\n        if (returnValue.owner.toLowerCase() === account.toLowerCase()) returnValues.push(returnValue);\r\n    })\r\n    return returnValues;\r\n\r\n        // let lockedTokenLists = [];\r\n        // for (const [key, value] of Object.entries(response.results)) {\r\n        //     lockedTokenLists.push(value.callsReturnContext[0][\"returnValues\"][0]);\r\n        // }\r\n        // contractCallContext = [];\r\n        // for (let i = 0; i < length; i++) {\r\n        //     contractCallContext.push({\r\n        //         reference: i,\r\n        //         contractAddress: lockerAddress,\r\n        //         abi: lockerContractAbi,\r\n        //         calls: [{ reference: 'lockedTokensCall', methodName: 'getUserTokenInfo', methodParameters: [lockedTokenLists[i], account] }]\r\n        //     })\r\n        // }\r\n        // response = await multicall.call(contractCallContext);\r\n        // let userInfo = [];\r\n        // for (const [key, value] of Object.entries(response.results)) {\r\n        //     if (web3.utils.hexToNumberString(value.callsReturnContext[0].returnValues[2].hex) == '0') continue;\r\n        //     userInfo.push({token: lockedTokenLists[key], deposited: web3.utils.hexToNumberString(value.callsReturnContext[0].returnValues[0].hex), withdrawed: web3.utils.hexToNumberString(value.callsReturnContext[0].returnValues[1].hex), vestLength: web3.utils.hexToNumberString(value.callsReturnContext[0].returnValues[2].hex)})\r\n        // }\r\n        // if (!userInfo.length) return [];\r\n        // contractCallContext = [];\r\n        // for (let i = 0; i < userInfo.length; i++) {\r\n        //     let context = {\r\n        //         reference: i,\r\n        //         contractAddress: lockerAddress,\r\n        //         abi: lockerContractAbi,\r\n        //         calls: []\r\n        //     }\r\n        //     for (let j = 0; j < userInfo[i][\"vestLength\"]; j++) {\r\n        //         context.calls.push({ reference: 'getUserVestingAtIndexCall', methodName: 'getUserVestingAtIndex', methodParameters: [userInfo[i].token, account, j] });\r\n        //     }\r\n        //     contractCallContext.push(context)\r\n        // }\r\n        // response = await multicall.call(contractCallContext);\r\n        // for (const [key, value] of Object.entries(response.results)) {\r\n        //     userInfo[key][\"vesting\"] = value.callsReturnContext.map(each => {\r\n        //         return each.returnValues.map(data => {\r\n        //             return web3.utils.hexToNumberString(data.hex)\r\n        //         })\r\n        //     })\r\n        // }\r\n        // contractCallContext = [];\r\n        // for (let i = 0; i < userInfo.length; i++) {\r\n        //     let context = {\r\n        //         reference: i,\r\n        //         contractAddress: userInfo[i][\"token\"],\r\n        //         abi: erc20Abi,\r\n        //         calls: [{ reference: 'decimalsCall', methodName: 'decimals' }, { reference: 'symbolCall', methodName: 'symbol'}]\r\n        //     }\r\n        //     contractCallContext.push(context);\r\n        // }\r\n        // response = await multicall.call(contractCallContext);\r\n        // for (const [key, value] of Object.entries(response.results)) {\r\n        //     userInfo[key][\"decimals\"] = value.callsReturnContext[0][\"returnValues\"][0];\r\n        //     userInfo[key][\"symbol\"] = value.callsReturnContext[1][\"returnValues\"][0];\r\n        // }\r\n        // let currentTime = Math.round(Date.now() / 1000);\r\n        // // console.log(userInfo)\r\n        // userInfo = userInfo.map(each => {\r\n        //     console.log(each);\r\n        //     let withdrawable = web3.utils.toBN(0);\r\n        //     each.vesting.map((eachVest) => {\r\n        //         if (Number(eachVest[0]) < currentTime) withdrawable = withdrawable.add(web3.utils.toBN(eachVest[1]));\r\n        //     })\r\n        //     withdrawable = withdrawable.sub(web3.utils.toBN(each.withdrawed));\r\n        //     each.withdrawable = withdrawable.toString();\r\n        //     return each;\r\n        // })\r\n    }\r\n    \r\nexport const getData = async (account) => {\r\n    const response = await axios.get(`${serverApi}/locker/lockedtokens/${account}`);\r\n    const lockerDataByWallet = response.data;\r\n    return lockerDataByWallet;\r\n}\r\n\r\nexport const getLockedTokenDetails = async (tokenAddress, account) => {\r\n\r\n    // const tokenData = data.find(each => each.address === tokenAddress);\r\n    \r\n    const rawData = await getRawData(account);\r\n    let web3 = new Web3(provider);\r\n\r\n    let tokenLocked = BigInt(0);\r\n    rawData.map(each => {\r\n        if (each.token === tokenAddress && !each.isWithdrawn) tokenLocked = tokenLocked + BigInt(each.amount);\r\n    });\r\n    // console.log(rawData)\r\n    const tokenContract = new web3.eth.Contract(erc20Abi, tokenAddress);\r\n    let symbol = await tokenContract.methods.symbol().call();\r\n    let decimals = await tokenContract.methods.decimals().call();\r\n    let totalSupply = await tokenContract.methods.totalSupply().call();\r\n    let liquidityLocked = BigInt(0);\r\n    let tokenLockHistory = [];\r\n\r\n    const multicall = new Multicall({ web3Instance: web3, tryAggregate: true });\r\n    let contractCallContext = rawData.map((each, index) => {\r\n        return {\r\n            reference: index,\r\n            contractAddress: each.token,\r\n            abi: erc20Abi,\r\n            calls: [{ reference: 'symbolsCall', methodName: 'symbol' }]\r\n        }\r\n    })\r\n    let response = await multicall.call(contractCallContext);\r\n    let symbols = [];\r\n    for (const [key, value] of Object.entries(response.results)) {\r\n        symbols.push(value.callsReturnContext[0].returnValues[0]);\r\n    }\r\n    // console.log(rawData)\r\n    for (let i = 0; i < rawData.length; i++) {\r\n        let each = rawData[i];\r\n        let address = each.token;\r\n        let ownerAddress = each.owner;\r\n        let tokenAmount = each.amount;\r\n        let timestamp = each.timestamp;\r\n        let isWithdrawn = each.isWithdrawn;\r\n        //default token\r\n        if (address.toLowerCase() === tokenAddress.toLowerCase()) tokenLockHistory.push({id: each.id, address: address, owner: ownerAddress, tokenAmount: tokenAmount, timestamp: timestamp, isWithdrawn: isWithdrawn});\r\n        //pool token\r\n        else if (symbols[i] === 'HUL') {\r\n            let poolContract = new web3.eth.Contract(liquidityPoolAbi, each.token);\r\n            let token0 = await poolContract.methods.token0().call();\r\n            let token1 = await poolContract.methods.token1().call();\r\n            if (token0.toLowerCase() === tokenAddress.toLowerCase() || token1.toLowerCase() === tokenAddress.toLowerCase()) {\r\n                let totalSupply = await poolContract.methods.totalSupply().call();\r\n                let baseTokenTotalAmount = await tokenContract.methods.balanceOf(address).call();\r\n                let baseTokenAmount = BigInt(baseTokenTotalAmount) * BigInt(tokenAmount) / BigInt(totalSupply);\r\n                if (!each.isWithdrawn) liquidityLocked = liquidityLocked + baseTokenAmount;\r\n                tokenLockHistory.push({id: each.id, isPool: true, address: address, owner: ownerAddress, tokenAmount: tokenAmount, baseTokenAmount: baseTokenAmount.toString(), timestamp: timestamp, isWithdrawn: isWithdrawn});\r\n            }\r\n        }\r\n    }\r\n    // let tokenSymbol = await tokenContract.methods.symbol().call();\r\n    // let tokenDecimals = await tokenContract.methods.decimals().call();\r\n    // let tokenLocked = await tokenContract.methods.balanceOf(lockerAddress).call();\r\n    // let tokenTotalSupply = await tokenContract.methods.totalSupply().call();\r\n\r\n    let lockerContract = new web3.eth.Contract(lockerContractAbi, lockerAddress);\r\n    let depositEvents = await lockerContract.getPastEvents(\"LogLocking\", {\r\n        fromBlock: 0\r\n    })\r\n    let withdrawEvents = await lockerContract.getPastEvents(\"LogWithdrawal\", {\r\n        fromBlock: 0\r\n    })\r\n\r\n    // let tokenTransferEvents = await tokenContract.getPastEvents(\"Transfer\",{\r\n    //     fromBlock: 0,\r\n    //     toBlock: \"latest\",\r\n    //     filter: {\r\n    //         to: lockerAddress\r\n    //     }\r\n    // })\r\n    // let tokenTransferTransactions = await Promise.all(tokenTransferEvents.map(each => web3.eth.getTransaction(each.transactionHash)))\r\n    // tokenTransferTransactions = tokenTransferTransactions.filter(each => each.input.length === 266);\r\n    \r\n    \r\n    for(let i=0; i<depositEvents.length; i++) {\r\n        let blockDetail = await web3.eth.getBlock(depositEvents[i].blockNumber);\r\n        depositEvents[i].timestamp = blockDetail.timestamp;\r\n    }\r\n    for(let i=0; i<withdrawEvents.length; i++) {\r\n        let blockDetail = await web3.eth.getBlock(withdrawEvents[i].blockNumber);\r\n        withdrawEvents[i].timestamp = blockDetail.timestamp;\r\n    }\r\n    let events = [], j = 0;\r\n    for(let i=0; i<depositEvents.length;i++) {\r\n        if(withdrawEvents[j] && withdrawEvents[j].returnValues.index === depositEvents[i].returnValues.index) {\r\n            events.push({deposit: depositEvents[i], withdraw: withdrawEvents[j]});\r\n            j++;\r\n        } else {\r\n            events.push({deposit: depositEvents[i]});\r\n        }\r\n    }\r\n\r\n    return {\r\n        address: tokenAddress,\r\n        symbol: symbol,\r\n        decimals: decimals,\r\n        totalSupply: totalSupply,\r\n        liquidityLocked: liquidityLocked,\r\n        tokenLocked: tokenLocked,\r\n        history: tokenLockHistory,\r\n        events: events\r\n    }\r\n}\r\n\r\nexport const checkWalletAddress = (walletAddress) => {\r\n    let web3 = new Web3(provider);\r\n    return web3.utils.isAddress(walletAddress);\r\n}\r\n\r\nexport const getLastDeployedContract = async (account) => {\r\n    const response = await axios.get(`${serverApi}/vesting/lastDeployed/${account}`);\r\n    const lastDeployedAddress = response.data;\r\n    return lastDeployedAddress;\r\n}\r\n\r\nexport const deployContract = async (provider, account, token) => {\r\n    const web3 = new Web3(provider);\r\n    const abi = [{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"createTokenLocker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"locker\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}]\r\n    const contract = new web3.eth.Contract(abi, swapTokenLockerFactory);\r\n    let result = contract.methods.createTokenLocker(token).send({\r\n        from: account\r\n    })\r\n    return result;\r\n}\r\n\r\nexport const sendTokenVesting = async (provider, deployedContract, csvData, token, account) => {\r\n    let _users = [], _amounts = [], _lockHours = [], _sendAmount = BigInt(0);\r\n    const web3 = new Web3(provider);\r\n    let abi = [{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}];\r\n    let contract = new web3.eth.Contract(abi, token);\r\n    let decimals = await contract.methods.decimals().call();\r\n    csvData.map(each => {\r\n        _users.push(each.address);\r\n        _amounts.push(BigInt(each.amount * Math.pow(10, decimals)).toString());\r\n        switch(each.period[each.period.length - 1]) {\r\n            case 'M':\r\n                _lockHours.push(each.period.slice(0, each.period.length - 1) * 30 * 24);\r\n                break;\r\n            case 'W':\r\n                _lockHours.push(each.period.slice(0, each.period.length - 1) * 7 * 24);\r\n                break;\r\n            case 'D':\r\n                _lockHours.push(each.period.slice(0, each.period.length - 1) * 24);\r\n                break;\r\n            case 'h':\r\n                _lockHours.push(each.period.slice(0, each.period.length - 1));\r\n                \r\n        }\r\n        _sendAmount += BigInt(each.amount * Math.pow(10, decimals));\r\n    })\r\n    _sendAmount = _sendAmount.toString();\r\n    abi = [{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"uint128[]\",\"name\":\"_amounts\",\"type\":\"uint128[]\"},{\"internalType\":\"uint32[]\",\"name\":\"_lockHours\",\"type\":\"uint32[]\"},{\"internalType\":\"uint256\",\"name\":\"_sendAmount\",\"type\":\"uint256\"}],\"name\":\"sendLockTokenMany\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feesInETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]\r\n    \r\n    contract = new web3.eth.Contract(abi, deployedContract)\r\n    let feesInETH = await contract.methods.feesInETH().call();\r\n    console.log(_users, _amounts, _lockHours, _sendAmount, account)\r\n    let result = await contract.methods.sendLockTokenMany(_users, _amounts, _lockHours, _sendAmount).send({\r\n        from: account,\r\n        value: BigInt(feesInETH * Math.pow(10, 18)).toString()\r\n    });\r\n    return result;\r\n}\r\n\r\nexport const getClaimTokenList = async (address) => {\r\n    const web3 = new Web3(provider);\r\n    let factoryContract, abi, erc20Abi, allContracts, response, multicall, contractCallContext;\r\n    abi = [{\"inputs\":[],\"name\":\"getAllContracts\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}];\r\n    factoryContract = new web3.eth.Contract(abi, swapTokenLockerFactory);\r\n    allContracts = await factoryContract.methods.getAllContracts().call();\r\n    multicall = new Multicall({ web3Instance: web3, tryAggregate: true });\r\n    abi = [{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getLockData\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}];\r\n    erc20Abi = [{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]\r\n    contractCallContext = allContracts.map((each, index) => {\r\n        return {\r\n            reference: index,\r\n            contractAddress: each,\r\n            abi: abi,\r\n            calls: [\r\n                { reference: 'getLockDataCall', methodName: 'getLockData', methodParameters: [address] },\r\n                { reference: 'getTokenCall', methodName: 'getToken'}\r\n            ]\r\n        }\r\n    })\r\n    response = await multicall.call(contractCallContext);\r\n    let returnData = [];\r\n    contractCallContext = [];\r\n    for (const [key, value] of Object.entries(response.results)) {\r\n        let amount = BigInt(value.callsReturnContext[0].returnValues[0].hex).toString();\r\n        let claimedAmount = BigInt(value.callsReturnContext[0].returnValues[1].hex).toString();\r\n        let lockTimestamp = BigInt(value.callsReturnContext[0].returnValues[2].hex).toString();\r\n        let lastUpdated = BigInt(value.callsReturnContext[0].returnValues[3].hex).toString();\r\n        let lockHours = value.callsReturnContext[0].returnValues[4];\r\n        let contract = allContracts[key];\r\n        let token = value.callsReturnContext[1].returnValues[0];\r\n        if (amount !== '0') {\r\n            contractCallContext.push({\r\n                reference: returnData.length,\r\n                contractAddress: token,\r\n                abi: erc20Abi,\r\n                calls: [\r\n                    { reference: 'nameCall', methodName: 'name' },\r\n                    { reference: 'decimalsCall', methodName: 'decimals' },\r\n                    { reference: 'symbolCall', methodName: 'symbol' }\r\n                ]\r\n            })\r\n            returnData.push({\r\n                amount: amount,\r\n                claimedAmount: claimedAmount,\r\n                lockTimestamp: lockTimestamp,\r\n                lastUpdated: lastUpdated,\r\n                lockHours: lockHours,\r\n                contract: contract,\r\n                token: {\r\n                    address: token\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    response = await multicall.call(contractCallContext);\r\n    for (const [key, value] of Object.entries(response.results)) {\r\n        let name = value.callsReturnContext[0].returnValues[0];\r\n        let symbol = value.callsReturnContext[2].returnValues[0];\r\n        let decimals = value.callsReturnContext[1].returnValues[0];\r\n        returnData[key].token.name = name;\r\n        returnData[key].token.symbol = symbol;\r\n        returnData[key].token.decimals = decimals;\r\n    }\r\n    return returnData;\r\n}\r\n\r\nexport const claimToken = async (provider, tokenDetail, account) => {\r\n    let currentTimestamp = Math.floor(Date.now() / 1000);\r\n    if (currentTimestamp - tokenDetail.lastUpdated < 3600) return {state: false, reason: 'Wait to next claim available'};\r\n    const passedHours = Math.floor((currentTimestamp - tokenDetail.lockTimestamp) / 3600);\r\n    const availableAmount = BigInt(Math.floor(tokenDetail.amount * passedHours / tokenDetail.lockHours) - tokenDetail.claimedAmount).toString();\r\n    const web3 = new Web3(provider);\r\n    const abi = [{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_amount\",\"type\":\"uint128\"}],\"name\":\"claimToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]\r\n    const contract = new web3.eth.Contract(abi, tokenDetail.contract);\r\n    const response = await contract.methods.claimToken(availableAmount).send({\r\n        from: account\r\n    });\r\n    console.log(response);\r\n}\r\n\r\nexport const airdrop = async (provider, csvData, token, account) => {\r\n    let _users = [], _amounts = [];\r\n    const web3 = new Web3(provider);\r\n    let abi = [{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}];\r\n    console.log(token)\r\n    let contract = new web3.eth.Contract(abi, token);\r\n    let decimals = await contract.methods.decimals().call();\r\n    csvData.map(each => {\r\n        _users.push(each.address);\r\n        _amounts.push(BigInt(each.amount * Math.pow(10, decimals)).toString());\r\n    })\r\n    abi = [{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"uint128[]\",\"name\":\"_amounts\",\"type\":\"uint128[]\"}],\"name\":\"airdrop\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]\r\n    contract = new web3.eth.Contract(abi, airdropAddress);\r\n    let result = await contract.methods.airdrop(token, _users, _amounts).send({\r\n        from: account\r\n    });\r\n    return result;\r\n}"],"sourceRoot":""}